import {Answer} from '../interfaces/answer.type.ts';

const getPrendusServerEndpointDomain = (): string => {
    if (window.location.hostname === 'localhost') {
        return `http://localhost:5000`;
    }
    else {
        return `https://prenduslearning.com`;
    }
};

const createUUID = () => {
    //From persistence.js; Copyright (c) 2010 Zef Hemel <zef@zef.me> * * Permission is hereby granted, free of charge, to any person * obtaining a copy of this software and associated documentation * files (the "Software"), to deal in the Software without * restriction, including without limitation the rights to use, * copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following * conditions: * * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR * OTHER DEALINGS IN THE SOFTWARE.
	var s: any[] = [];
	var hexDigits = "0123456789ABCDEF";
	for ( var i = 0; i < 32; i++) {
		s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
	}
	s[12] = "4";
	s[16] = hexDigits.substr((s[16] & 0x3) | 0x8, 1);

	var uuid = s.join("");
	return uuid;
};

const handleServerSideError = (error: any, res: any) => {

    console.log(error);

    if (error.status === 403) {
        res.status(403).json({
            errorMessage: error.errorMessage
        });
        return;
    }

    if (error.status === 401) {
        res.status(401).json({
            errorMessage: error.errorMessage
        });
        return;
    }

    if (process.env.NODE_ENV === 'production') {
        res.status(500).json({
            errorMessage: 'Sorry, internal server error. Try again.'
        });
    }
    else {
        res.status(500).json({
            errorMessage: error.toString()
        });
    }
};

function getUserAnswerString(answerInputValue: string, userInputs: string[], userCheckboxes: string[], userRadios: string[], questionSessionId: string) {
    if (Object.keys(userInputs).length !== 0) {
        const inputElements = userInputs.map((inputId) => {
            return document.getElementById(inputId + questionSessionId);
        });

        const inputAnswerString = constructAnswerString(inputElements, getInputContents);

        return inputAnswerString;

        function getInputContents(element: HTMLElement) {
            return element.innerHTML;
        }
    }

    if (Object.keys(userCheckboxes).length !== 0) {

        const paperCheckboxElements = userCheckboxes.map((checkboxId) => {
            return document.getElementById(checkboxId + questionSessionId);
        });

        const checkboxAnswerString = constructAnswerString(paperCheckboxElements, getCheckboxLabel);

        return checkboxAnswerString;

        function getCheckboxLabel(element: HTMLElement) {
            if (element.checked) {
                return element.parentElement.childNodes[2].textContent.trim();
            }
            else {
                return '';
            }
        }
    }

    if (Object.keys(userRadios).length !== 0) {

        const paperRadioElements = userRadios.map((radioId) => {
            return document.getElementById(radioId + questionSessionId);
        });

        const radioAnswerString = constructAnswerString(paperRadioElements, getRadioLabel);

        return radioAnswerString;

        function getRadioLabel(element: HTMLElement) {
            if (element.checked) {
                return element.querySelector('#radioLabel').innerHTML.trim();
            }
            else {
                return '';
            }
        }
    }

    return answerInputValue;
}

function constructAnswerString(items: HTMLElement[], retrieveText: (element: HTMLElement) => string) {
    return items.reduce((prev, curr) => {
        const comma = prev ? ', ' : '';
        return prev + comma + retrieveText(curr);
    }, '');
}

function getAnswerString(answer: Answer, userInputs: string[], userCheckboxes: string[], userRadios: string[], questionSessionId: string) {
    if (Object.keys(userInputs).length !== 0) {
        return userInputs.reduce((prev, curr) => {
            const comma = prev ? ', ' : '';
            return prev + comma + answer[curr];
        }, '');
    }

    if (Object.keys(userCheckboxes).length !== 0) {

        const filteredCheckboxes = userCheckboxes.filter((element) => {
            return answer[element];
        });

        const paperCheckboxElements = filteredCheckboxes.map((checkboxId) => {
            return document.getElementById(checkboxId + questionSessionId);
        });

        const checkboxAnswerString = constructAnswerString(paperCheckboxElements, getCheckboxLabel);

        return checkboxAnswerString;

        function getCheckboxLabel(element: HTMLElement) {
            return element.parentElement.childNodes[2].textContent.trim();
        }
    }

    if (Object.keys(userRadios).length !== 0) {
        const filteredRadios = userRadios.filter((element) => {
            return answer[element];
        });

        const paperRadioElements = filteredRadios.map((radioId) => {
            return document.getElementById(radioId + questionSessionId);
        });

        const radioAnswerString = constructAnswerString(paperRadioElements, getRadioLabel);

        return radioAnswerString;

        function getRadioLabel(element: HTMLElement) {
            return element.querySelector('#radioLabel').innerHTML.trim();
        }
    }

    return answer;
}

export const UtilitiesService = {
    getPrendusServerEndpointDomain,
    createUUID,
    handleServerSideError,
    getAnswerString,
    getUserAnswerString
};
