import {FirebaseService} from '../services/firebase.service.ts';
import {Concept} from '../interfaces/concept.interface.ts';
import {VideoModel} from './video.model.ts';
import {QuizModel} from './quiz.model.ts';
import {UtilitiesService} from '../services/utilities.service.ts';
import {Video} from '../interfaces/video.interface.ts';
import {CourseConceptData} from '../interfaces/course-concept-data.interface.ts';

const dataPath = 'concepts';
const save = async (id: string, data: Concept): Promise<string> => {
  try{
    if (id) {
        const path = `${dataPath}/${id}`;
        await FirebaseService.set(path, data);
        return id;
    }
    else {
        const path = dataPath;
        const conceptId =  await FirebaseService.push(path, data);
        return conceptId;
    }
  }catch(error){
    throw error;
  }
};
const getById = async (id: string) => {
  try{
    const path = `${dataPath}/${id}`
    const concept = await FirebaseService.get(path);
    return concept;
  }catch(error){
    return error;
  }
};

const deleteConcept = async (key: string) => {
  try{
    const path = `${dataPath}/${key}`;
    let conceptDelete = await FirebaseService.remove(path);
  }catch(error){
    throw error;
  }
};
const conceptsObjectToArray = (conceptsObject: Concept) => {
  try{
    var conceptsArray = Object.keys(conceptsObject).map(function (key) {return conceptsObject[key]});
    return conceptsArray;
  }catch(error){
    throw error;
  }
}

const associateCollaborator = async (conceptId: string, uid: string): Promise<void> => {
    try {
        //TODO it would be nice to do the following in a transaction, so that if adding collaborators fails anywhere it fails everywhere
        const path = `${dataPath}/${conceptId}/collaborators/${uid}`;
        await FirebaseService.set(path, uid);

        const videosPath = `${dataPath}/${conceptId}/videos`;
        const videosObject = await FirebaseService.get(videosPath);
        const videoIds = Object.keys(videosObject || {});

        await UtilitiesService.asyncForEach(videoIds, async (videoId: string) => {
            await VideoModel.associateCollaborator(videoId, uid);
        });

        const quizzesPath = `${dataPath}/${conceptId}/quizzes`;
        const quizzesObject = await FirebaseService.get(quizzesPath);
        const quizIds = Object.keys(quizzesObject || {});

        await UtilitiesService.asyncForEach(quizIds, async (quizId: string) => {
            await QuizModel.associateCollaborator(quizId, uid);
        });
    }
    catch(error) {
        throw error;
    }
};

const disassociateCollaborator = async (conceptId: string, uid: string): Promise<void> => {
    try {
        //TODO it would be nice to do the following in a transaction, so that if adding collaborators fails anywhere it fails everywhere
        const path = `${dataPath}/${conceptId}/collaborators/${uid}`;
        await FirebaseService.remove(path);

        const videosPath = `${dataPath}/${conceptId}/videos`;
        const videosObject = await FirebaseService.get(videosPath);
        const videoIds = Object.keys(videosObject || {});

        await UtilitiesService.asyncForEach(videoIds, async (videoId: string) => {
            await VideoModel.disassociateCollaborator(videoId, uid);
        });

        const quizzesPath = `${dataPath}/${conceptId}/quizzes`;
        const quizzesObject = await FirebaseService.get(quizzesPath);
        const quizIds = Object.keys(quizzesObject || {});

        await UtilitiesService.asyncForEach(quizIds, async (quizId: string) => {
            await QuizModel.disassociateCollaborator(quizId, uid);
        });
    }
    catch(error) {
        throw error;
    }
};

const getCollaboratorUids = async (conceptId: string): Promise<string[]> => {
    try {
      const path = `${dataPath}/${conceptId}/collaborators`;
      const collaboratorUidsObject = await FirebaseService.get(path);
      const collaboratorUids = Object.keys(collaboratorUidsObject || {});
      return collaboratorUids;
    }
    catch(error){
      throw error;
    }
};

const getVideoIds = async (conceptId: string): Promise<string[]> => {
    try {
        const path = `${dataPath}/${conceptId}/videos`;
        const videoIdsObject = await FirebaseService.get(path);
        const videoIds = Object.keys(videoIdsObject || {});

        return videoIds;
    }
    catch(error) {
        throw error;
    }
};

const getQuizIds = async (conceptId: string): Promise<string[]> => {
    try {
        const path = `${dataPath}/${conceptId}/quizzes`;
        const quizIdsObject = await FirebaseService.get(path);
        const quizIds = Object.keys(quizIdsObject || {});

        return quizIds;
    }
    catch(error) {
        throw error;
    }
};

const resolveConceptIds = async (conceptIds: string[]): Promise<Concept[]> => {
    try {
      const concepts = await asyncReduce(conceptIds, []);
      return concepts;

      async function asyncReduce(conceptIds: string[], concepts: Concept[]): Promise<Concept[]> {

          if (conceptIds.length === 0) {
              return concepts;
          }

          const conceptId = conceptIds[0];
          const concept = await getById(conceptId);

          return asyncReduce(conceptIds.slice(1), [...concepts, concept]);
      }
    }
    catch(error) {
      throw error;
    }
};

const associateVideo = async (conceptId: string, videoId: string) => {
    try {
        const path = `${dataPath}/${conceptId}/videos/${videoId}`;
        await FirebaseService.set(path, videoId);
    }
    catch(error) {
        throw error;
    }
};

const disassociateVideo = async (conceptId: string, videoId: string) => {
    try {
        const path = `${dataPath}/${conceptId}/videos/${videoId}`;
        await FirebaseService.remove(path);
    }
    catch(error) {
        throw error;
    }
};

const associateQuiz = async (conceptId: string, quizId: string) => {
    try {
        const path = `${dataPath}/${conceptId}/quizzes/${quizId}`;
        await FirebaseService.set(path, quizId);
    }
    catch(error) {
        throw error;
    }
};

const disassociateQuiz = async (conceptId: string, quizId: string) => {
    try {
        const path = `${dataPath}/${conceptId}/quizzes/${quizId}`;
        await FirebaseService.remove(path);
    }
    catch(error) {
        throw error;
    }
};

export const ConceptModel = {
    save,
    getById,
    deleteConcept,
    conceptsObjectToArray,
    associateCollaborator,
    disassociateCollaborator,
    getCollaboratorUids,
    dataPath,
    resolveConceptIds,
    associateVideo,
    disassociateVideo,
    associateQuiz,
    disassociateQuiz,
    getVideoIds,
    getQuizIds
}
