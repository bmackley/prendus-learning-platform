import {Question} from '../interfaces/question.interface.ts';
import {QuestionVisibility} from '../interfaces/question-visibility.type.ts';
import {FirebaseService} from '../services/firebase.service.ts';

const dataPath = 'questions';

const save = async (id: string, data: Question): Promise<string> => {
    try {
        const user: any = await FirebaseService.getLoggedInUser();

        const dataWithUid: Question = Object.assign({}, data, {
            uid: user.uid
        });

        if (id) {
            const path: string = `${dataPath}/${id}`;
            await FirebaseService.set(path, dataWithUid);

            return id;
        }
        else {
            const timestampEnabledData: Question = Object.assign({}, dataWithUid, {
                timestamp: window.firebase.database.ServerValue.TIMESTAMP
            });

            const path: string = dataPath;
            return await FirebaseService.push(path, timestampEnabledData);
        }
    }
    catch(error) {
        throw error;
    }
};

const update = async (id: string, data: Question): Promise<void> => {
    try {
        const path = `${dataPath}/${id}`;
        await FirebaseService.update(path, data);
    }
    catch(error) {
        throw error;
    }
};

const removeById = async (id: string): Promise<void> => {
    try {
        await FirebaseService.remove(`${dataPath}/${id}`);
    }
    catch(error) {
        throw error;
    }
};

const getById = async (id: string): Promise<Question> => {
    try {
        const path: string = `${dataPath}/${id}`;
        const question: Question = await FirebaseService.get(path);
        return question;
    }
    catch(error) {
        throw error;
    }
};

const getAllIdsBy = async (fieldName: string, fieldValue: string | QuestionVisibility): Promise<string[]> => {
    try {
        const path = `${dataPath}`;

        const questionsObject = await FirebaseService.getAllBy(path, fieldName, fieldValue);
        const questionsArray = Object.keys(questionsObject || {}).map((key) => {
            return Object.assign({}, questionsObject[key], {
                id: key
            });
        });
        const noPreviewQuestionsArray = questionsArray.filter((element) => {
            return element.previewQuestionId;
        });
        const noPreviewsQuestionsKeys = noPreviewQuestionsArray.map((element) => {
            return element.id;
        });

        return noPreviewsQuestionsKeys;
    }
    catch(error) {
        throw error;
    }
};

const getAllIdsByUid = async (uid: string): Promise<string[]> => {
    try {
        return await getAllIdsBy('uid', uid);
    }
    catch(error) {
        throw error;
    }
};

const getAllIdsByVisibility = async (visibility: QuestionVisibility): Promise<string[]> => {
    try {
        return await getAllIdsBy('visibility', visibility);
    }
    catch(error) {
        throw error;
    }
};

const resolveQuestionIds = async (questionIds: string[]): Promise<Question[]> => {
    try {
      const questions = await asyncReduce(questionIds, []);
      return questions;

      async function asyncReduce(questionIds: string[], questions: Question[]): Promise<Question[]> {

          if (questionIds.length === 0) {
              return questions;
          }

          const questionId = questionIds[0];
          const question = await getById(questionId);

          return asyncReduce(questionIds.slice(1), [...questions, question]);
      }
    }
    catch(error) {
      throw error;
    }
};

export const QuestionModel = {
    save,
    getById,
    removeById,
    update,
    getAllIdsByUid,
    getAllIdsByVisibility,
    resolveQuestionIds
};
