import {FirebaseService} from '../services/firebase.service.ts';
import {Course} from '../interfaces/course.interface.ts';
import {Concept} from '../interfaces/concept.interface.ts';
import {CourseVisibility} from '../interfaces/course-visibility.type.ts';
import {ConceptModel} from './concept.model.ts';
import {UtilitiesService} from '../services/utilities.service.ts';
import {CourseConceptData} from '../interfaces/course-concept-data.interface.ts';

const conceptsPath = 'concepts';
const dataPath = 'courses'
const createOrUpdate = async (id: string, data: Course): Promise<string> => {
    try{
      if (id) {
      const path = `${dataPath}/${id}`;
      await FirebaseService.update(path, data);
      return id;
      }
      else {
        const path = dataPath;
        return await FirebaseService.push(path, data);
      }
    }catch(error){
      throw error;
    }
};
<<<<<<< HEAD

const associateConcept = async (courseId: string, conceptId: string, pos: number) => {
  try{
    const path = `${dataPath}/${courseId}/concepts/${conceptId}`;
    const conceptData = {
      id: conceptId,
      position: pos,
    };
    await FirebaseService.set(path, conceptData);
=======
const createCourseConcept = async (id: string, conceptId: string, pos: number): Promise<string> => {
  try{
    const path = `${dataPath}/${id}/concepts/`;
    const conceptData = {
      id: conceptId,
      position: pos,
    }
    await FirebaseService.push(path, conceptData);
    return id;
>>>>>>> develop
  }catch(error){
    throw error;
  }
};

const disassociateConcept = async (courseId: string, conceptId: string) => {
    try {
        const path = `${dataPath}/${courseId}/concepts/${conceptId}`;
        await FirebaseService.remove(path);
    }
    catch(error) {
        throw error;
    }
};

const deleteCourseConcept = async (id: string, conceptId: string) => {
    try{
      const path =  `${dataPath}/${id}/concepts/${conceptId}/`;
      return await FirebaseService.remove(path);
    }catch(error){
      throw error;
    }
};
const getById = async (id:string) => {
    try{
      const path = `${dataPath}/${id}`;
      const course = await FirebaseService.get(path);
      course.id = id;
      return course;
    }catch(error){
      throw error;
    }
};
const getCoursesByUser = async (uid: string) => {
    try{
      const path = dataPath;
      const firebaseCourses = await FirebaseService.getAllBy(path, 'uid', uid);
      const firebaseCoursesArray = Object.keys(firebaseCourses || {}).map(key => {
        return Object.assign({}, firebaseCourses[key], {
            id: key,
        });
      });
      return firebaseCoursesArray;
    }catch(error){
      throw error;
    }
};
const courseConceptsToArray = (course: Course) => {
  try{
      let courseConceptsArray = Object.keys(course.concepts || {}).map(key => {
      return Object.assign({}, course.concepts[key], {
          key: key,
      });
    });
    return courseConceptsArray;
  }catch(error){
    throw error;
  }
}
<<<<<<< HEAD
const orderCourseConcepts = (courseConcepts: CourseConceptData[]) => {
  try{
      const newCourseConcepts = [...courseConcepts];

=======
const orderCourseConcepts = (course: Course, courseConcepts: Concept) => {
  try{
>>>>>>> develop
    function compare(a: any,b: any) {
      if (a.position < b.position)
        return -1;
      if (a.position > b.position)
        return 1;
      return 0;
    }
<<<<<<< HEAD
    newCourseConcepts.sort(compare);
    return newCourseConcepts;
=======
    courseConcepts.sort(compare);
    course.concepts = courseConcepts;
    return course;
>>>>>>> develop
  }catch(error){
    throw error;
  }
}
const updateCourseConcepts = async (id:string, conceptArray: Concept) => {
  try{
    for(let key in conceptArray){
      const path =  `${dataPath}/${id}/concepts/${conceptArray[key].key}`;
      await FirebaseService.update(path, conceptArray[key]);
    }
    return;
  }catch(error){
    throw error;
  }

}
const deleteCourse = async (key: string) => {
    try{
      const path =  `${dataPath}/${key}`;
      return await FirebaseService.remove(path);
    }catch(error){
      throw error;
    }
};

<<<<<<< HEAD
const associateCollaborator = async (courseId: string, uid: string): Promise<void> => {
=======
const addCollaborator = async (courseId: string, uid: string): Promise<void> => {
>>>>>>> develop
    try {
        //TODO it would be nice to do the following in a transaction, so that if adding collaborators fails anywhere it fails everywhere
        const path = `${dataPath}/${courseId}/collaborators/${uid}`;
        await FirebaseService.set(path, uid);

        const conceptsPath = `${dataPath}/${courseId}/concepts`;
        const conceptsObject = await FirebaseService.get(conceptsPath);
        const conceptIds = Object.keys(conceptsObject || {});

        await UtilitiesService.asyncForEach(conceptIds, async (conceptId: string) => {
<<<<<<< HEAD
            await ConceptModel.associateCollaborator(conceptId, uid);
=======
            await ConceptModel.addCollaborator(conceptId, uid);
>>>>>>> develop
        });
    }
    catch(error) {
        throw error;
    }
};

<<<<<<< HEAD
const disassociateCollaborator = async (courseId: string, uid: string): Promise<void> => {
=======
const removeCollaborator = async (courseId: string, uid: string): Promise<void> => {
>>>>>>> develop
    try {
        //TODO it would be nice to do the following in a transaction, so that if adding collaborators fails anywhere it fails everywhere
        const path = `${dataPath}/${courseId}/collaborators/${uid}`;
        await FirebaseService.remove(path);

        const conceptsPath = `${dataPath}/${courseId}/concepts`;
        const conceptsObject = await FirebaseService.get(conceptsPath);
        const conceptIds = Object.keys(conceptsObject || {});

        await UtilitiesService.asyncForEach(conceptIds, async (conceptId: string) => {
<<<<<<< HEAD
            await ConceptModel.disassociateCollaborator(conceptId, uid);
=======
            await ConceptModel.removeCollaborator(conceptId, uid);
>>>>>>> develop
        });
    }
    catch(error) {
        throw error;
    }
};

const getCollaboratorUids = async (courseId: string): Promise<string[]> => {
    try {
      const path = `${dataPath}/${courseId}/collaborators`;
      const collaboratorUidsObject = await FirebaseService.get(path);
      const collaboratorUids = Object.keys(collaboratorUidsObject || {});
      return collaboratorUids;
    }
    catch(error) {
      throw error;
    }
};

const getAllByVisibility = async (visibility: CourseVisibility) => {
    try {
      const path = `${dataPath}`;

      const coursesObject = await FirebaseService.getAllBy(path, 'visibility', visibility);
      const coursesArray = Object.keys(coursesObject || {}).map((key) => {
          return Object.assign({}, coursesObject[key], {
              courseId: key
          });
      });

      return coursesArray;
    }
    catch(error) {
      throw error;
    }
};

<<<<<<< HEAD
const resolveCourseIds = async (courseIds: string[]): Promise<Course[]> => {
    try {
      const courses = await asyncReduce(courseIds, []);
=======
const resolveIds = async (ids: string[]): Promise<Course[]> => {
    try {
      const courses = await asyncReduce(ids, []);
>>>>>>> develop
      return courses;

      async function asyncReduce(courseIds: string[], courses: Course[]): Promise<Course[]> {

          if (courseIds.length === 0) {
              return courses;
          }

          const courseId = courseIds[0];
          const course = await getById(courseId);

          return asyncReduce(courseIds.slice(1), [...courses, course]);
      }
    }
    catch(error) {
      throw error;
    }
};

export const CourseModel = {
    createOrUpdate,
    getById,
    getCoursesByUser,
    deleteCourse,
    associateConcept,
    disassociateConcept,
    deleteCourseConcept,
    orderCourseConcepts,
    updateCourseConcepts,
    courseConceptsToArray,
    associateCollaborator,
    disassociateCollaborator,
    getCollaboratorUids,
    getAllByVisibility,
    resolveCourseIds,
    dataPath
}
