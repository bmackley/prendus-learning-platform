import {FirebaseService} from '../services/firebase.service.ts';
import {Course} from '../interfaces/course.interface.ts';
import {Concept} from '../interfaces/concept.interface.ts';
import {CourseVisibility} from '../interfaces/course-visibility.type.ts';

const conceptsPath = 'concepts';
const dataPath = 'courses'
const createOrUpdate = async (id: string, data: Course): Promise<string> => {
    if (id) {
      const path = `${dataPath}/${id}`;
      await FirebaseService.update(path, data);
      return id;
    }
    else {
      const path = dataPath;
      return await FirebaseService.push(path, data);
    }
};
const createCourseConcept = async (id: string, conceptId: string, pos: number): Promise<string> => {
  const path = `${dataPath}/${id}/concepts/`;
  const conceptData = {
    id: conceptId,
    position: pos,
  }
  await FirebaseService.push(path, conceptData);
  return id;
};
const deleteCourseConcept = async (id: string, conceptId: string) => {
    try{
      const path =  `${dataPath}/${id}/concepts/${conceptId}/`;
      return await FirebaseService.remove(path);
    }catch(error){
      throw error;
    }
};
const getById = async (id:string) => {
    const path = `${dataPath}/${id}`;
    const course = await FirebaseService.get(path);
    course.id = id;
    return course;
};
const getCoursesByUser = async (uid: string) => {
    const path = dataPath;
    const firebaseCourses = await FirebaseService.getAllBy(path, 'uid', uid);
    const firebaseCoursesArray = Object.keys(firebaseCourses || {}).map(key => {
      return Object.assign({}, firebaseCourses[key], {
          id: key,
      });
    });
    return firebaseCoursesArray;
};
const courseConceptsToArray = (course: Course) => {
  let courseConceptsArray = Object.keys(course.concepts || {}).map(key => {
    return Object.assign({}, course.concepts[key], {
        key: key,
    });
  });
  return courseConceptsArray;
}
const orderCourseConcepts = (course: Course, courseConcepts: Concept) => {
  function compare(a: any,b: any) {
    if (a.position < b.position)
      return -1;
    if (a.position > b.position)
      return 1;
    return 0;
  }
  courseConcepts.sort(compare);
  course.concepts = courseConcepts;
  return course;
}
const updateCourseConcepts = async (id:string, conceptArray: Concept) => {
  console.log(conceptArray);
  try{
    for(let key in conceptArray){
      const path =  `${dataPath}/${id}/concepts/${conceptArray[key].key}`;
      await FirebaseService.update(path, conceptArray[key]);
    }
    return;
  }catch(error){
    throw error;
  }

}
const deleteCourse = async (key: string) => {
    const path =  `${dataPath}/${key}`;
    return await FirebaseService.remove(path);

};

const addCollaborator = async (courseId: string, uid: string): Promise<void> => {
    const path = `${dataPath}/${courseId}/collaborators/${uid}`;
    await FirebaseService.set(path, uid);
};

const removeCollaborator = async (courseId: string, uid: string): Promise<void> => {
    const path = `${dataPath}/${courseId}/collaborators/${uid}`;
    await FirebaseService.remove(path);
};

const getCollaboratorUids = async (courseId: string): Promise<string[]> => {
    const path = `${dataPath}/${courseId}/collaborators`;
    const collaboratorUidsObject = await FirebaseService.get(path);
    const collaboratorUids = Object.keys(collaboratorUidsObject || {});

    return collaboratorUids;
};

const getAllByVisibility = async (visibility: CourseVisibility) => {
    const path = `${dataPath}`;

    const coursesObject = await FirebaseService.getAllBy(path, 'visibility', visibility);
    const coursesArray = Object.keys(coursesObject || {}).map((key) => {
        return Object.assign({}, coursesObject[key], {
            courseId: key
        });
    });

    return coursesArray;
};

const resolveIds = async (ids: string[]): Promise<Course[]> => {
    const courses = await asyncReduce(ids, []);
    return courses;

    async function asyncReduce(courseIds: string[], courses: Course[]): Promise<Course[]> {

        if (courseIds.length === 0) {
            return courses;
        }

        const courseId = courseIds[0];
        const course = await getById(courseId);

        return asyncReduce(courseIds.slice(1), [...courses, course]);
    }
};

export const CourseModel = {
    createOrUpdate,
    getById,
    getCoursesByUser,
    deleteCourse,
    createCourseConcept,
    deleteCourseConcept,
    orderCourseConcepts,
    updateCourseConcepts,
    courseConceptsToArray,
    addCollaborator,
    removeCollaborator,
    getCollaboratorUids,
    getAllByVisibility,
    resolveIds,
    dataPath
}
